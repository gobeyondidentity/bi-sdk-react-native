{"version":3,"names":["_EmbeddedNativeModules","require","_EmbeddedTypes","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","Embedded","authenticate","url","passkeyId","Promise","resolve","reject","EmbeddedNativeModules","then","response","toAuthenticateResponse","catch","authenticateOtp","email","bindPasskey","toBindPasskeyResponse","deletePasskey","id","getAuthenticationContext","toAuthenticationContext","getPasskeys","initialize","biometricAskPrompt","allowedDomains","isAuthenticateUrl","isBindPasskeyUrl","logEventEmitter","LoggerEventEmitter","redeemOtp","otp","authUrl","application","displayName","undefined","origin","sourceIp","userAgent","geolocation","referer","redirectUrl","message","passkeyBindingToken","passkey","postBindingRedirectUri"],"sources":["index.ts"],"sourcesContent":["import {\n  BILoggerEmitter,\n  EmbeddedNativeModules,\n  LoggerEventEmitter,\n  NativeAuthenticationContext,\n  NativeAuthenticateResponse,\n  NativeBindPasskeyResponse,\n} from './EmbeddedNativeModules';\n\nimport type {\n  AuthenticationContext,\n  AuthenticateResponse,\n  BindPasskeyResponse,\n  OtpChallengeResponse,\n  Passkey,\n  Success,\n} from './EmbeddedTypes';\n\ninterface Embedded {\n  /**\n   * Authenticate a user and receive an `AuthenticateResponse`.\n   * @param url The authentication URL of the current transaction.\n   * @param passkeyId the ID of the passkey with which to authenticate.\n   */\n  authenticate(url: string, passkeyId: string): Promise<AuthenticateResponse>;\n\n  /**\n   * Initiates authentication using an OTP, which will be sent to the provided email address.\n   * @param url The authentication URL of the current transaction.\n   * @param email The email address where the OTP will be sent.\n   */\n  authenticateOtp(url: string, email: string): Promise<OtpChallengeResponse>;\n\n  /**\n   * Bind a passkey to a device.\n   * @param url the URL used to bind a passkey to a device.\n   */\n  bindPasskey(url: string): Promise<BindPasskeyResponse>;\n\n  /**\n   * Delete a passkey by ID.\n   * @note it is possible to delete a passkey that does not exist.\n   * @warning deleting a passkey is destructive and will remove everything from the device. If no other device contains the passkey then the user will need to complete a recovery in order to log in again on this device.\n   * @param id the the passkey id, uniquely identifying a `Passkey`.\n   */\n  deletePasskey(id: string): Promise<string>;\n\n  /**\n   * Get all current passkeys for this device.\n   */\n  getPasskeys(): Promise<Passkey[]>;\n\n  /**\n   * Get the Authentication Context for the current transaction.\n   *\n   * The Authentication Context contains the Authenticator Config, Authentication Method Configuration, request origin, and the authenticating application.\n   * This is used to retrieve authentication parameters for an ongoing transaction.\n   * @param url The authentication URL of the current transaction.\n   */\n  getAuthenticationContext(url: string): Promise<AuthenticationContext>;\n\n  /**\n   * Initialize the SDK. This must be called before any other functions are called.\n   * Note: Hot reloading will not call this function again. If changes have been made to calling this function, fully reload the app to see those changes.\n   * @param biometricAskPrompt A prompt the user will see when asked for biometrics.\n   * @param allowedDomains An optional array of whitelisted domains for network operations. This will default to Beyond Identityâ€™s allowed domains when not provided or is empty.\n   */\n  initialize(\n    biometricAskPrompt: string,\n    allowedDomains?: string[]\n  ): Promise<Success>;\n\n  /**\n   * Returns whether a URL is a valid Authenticate URL or not.\n   * @param url The URL in question.\n   */\n  isAuthenticateUrl(url: string): Promise<boolean>;\n\n  /**\n   * Returns whether a URL is a valid Bind Passkey URL or not.\n   * @param url The URL in question.\n   */\n  isBindPasskeyUrl(url: string): Promise<boolean>;\n\n  /**\n   * A NativeEventEmitter to listen for `Logger` events after calling `Embedded.initialize`\n   */\n  logEventEmitter: BILoggerEmitter;\n\n  /**\n   * Redeems an OTP for a grant code.\n   *\n   * Returns a promise that resolves to an `AuthenticateResponse` on success\n   * or an `OtpChallengeResponse` on failure to authenticate with the provided OTP code.\n   * Use the url provided in `OtpChallengeResponse` for retry.\n   * @param url The authentication URL of the current transaction.\n   * @param otp The OTP to redeem.\n   */\n  redeemOtp(\n    url: string,\n    otp: string\n  ): Promise<AuthenticateResponse | OtpChallengeResponse>;\n}\n\nconst Embedded: Embedded = {\n  authenticate(url: string, passkeyId: string): Promise<AuthenticateResponse> {\n    return new Promise(function (resolve, reject) {\n      EmbeddedNativeModules.authenticate(url, passkeyId)\n        .then((response) => resolve(toAuthenticateResponse(response)))\n        .catch(reject);\n    });\n  },\n  authenticateOtp(url, email): Promise<OtpChallengeResponse> {\n    return new Promise(function (resolve, reject) {\n      EmbeddedNativeModules.authenticateOtp(url, email)\n        .then(resolve)\n        .catch(reject);\n    });\n  },\n  bindPasskey(url: string): Promise<BindPasskeyResponse> {\n    return new Promise(function (resolve, reject) {\n      EmbeddedNativeModules.bindPasskey(url)\n        .then((response) => resolve(toBindPasskeyResponse(response)))\n        .catch(reject);\n    });\n  },\n  deletePasskey(id: string): Promise<string> {\n    return EmbeddedNativeModules.deletePasskey(id);\n  },\n  getAuthenticationContext(url: string): Promise<AuthenticationContext> {\n    return new Promise(function (resolve, reject) {\n      EmbeddedNativeModules.getAuthenticationContext(url)\n        .then((response) => resolve(toAuthenticationContext(response)))\n        .catch(reject);\n    });\n  },\n  getPasskeys(): Promise<Passkey[]> {\n    return EmbeddedNativeModules.getPasskeys();\n  },\n  initialize(\n    biometricAskPrompt: string,\n    allowedDomains: string[] = []\n  ): Promise<Success> {\n    return EmbeddedNativeModules.initialize(allowedDomains, biometricAskPrompt);\n  },\n  isAuthenticateUrl(url: string): Promise<boolean> {\n    return EmbeddedNativeModules.isAuthenticateUrl(url);\n  },\n  isBindPasskeyUrl(url: string): Promise<boolean> {\n    return EmbeddedNativeModules.isBindPasskeyUrl(url);\n  },\n  logEventEmitter: LoggerEventEmitter,\n  redeemOtp(\n    url: string,\n    otp: string\n  ): Promise<AuthenticateResponse | OtpChallengeResponse> {\n    return new Promise(function (resolve, reject) {\n      EmbeddedNativeModules.redeemOtp(url, otp)\n        .then((response) => {\n          if ('redirectUrl' in response) {\n            resolve(toAuthenticateResponse(response));\n          }\n          if ('url' in response) {\n            resolve(response);\n          }\n        })\n        .catch(reject);\n    });\n  },\n};\n\nfunction toAuthenticationContext(\n  response: NativeAuthenticationContext\n): AuthenticationContext {\n  return {\n    authUrl: response.authUrl,\n    application: {\n      id: response.application.id,\n      displayName: response.application.displayName || undefined, // checking for empty string from native bridge\n    },\n    origin: {\n      sourceIp: response.origin.sourceIp || undefined, // checking for empty string from native bridge\n      userAgent: response.origin.userAgent || undefined, // checking for empty string from native bridge\n      geolocation: response.origin.geolocation || undefined, // checking for empty string from native bridge\n      referer: response.origin.referer || undefined, // checking for empty string from native bridge\n    },\n  };\n}\n\nfunction toAuthenticateResponse(\n  response: NativeAuthenticateResponse\n): AuthenticateResponse {\n  return {\n    redirectUrl: response.redirectUrl,\n    message: response.message || undefined, // checking for empty string from native bridge\n    passkeyBindingToken: response.passkeyBindingToken || undefined, // checking for empty string from native bridge\n  };\n}\n\nfunction toBindPasskeyResponse(\n  response: NativeBindPasskeyResponse\n): BindPasskeyResponse {\n  return {\n    passkey: response.passkey,\n    postBindingRedirectUri: response.postBindingRedirectUri || undefined, // checking for empty string from native bridge\n  };\n}\n\nexport { Embedded };\nexport * from './EmbeddedTypes';\n"],"mappings":"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","ignoreList":[]}